# 3.1
略

# 3.2
* 隐式设备初始化 —— 在第一次调用一个和设备管理与版本查询功能无关的runtime API时设备（即GPU）将自动初始化。
* 所有runtime API均以cuda开头。
* cudaError_t，runtime API返回类型，若调用成功，返回的为cudaSuccess。
* 设备内存的分配 —— cudaError_t cudaMalloc(void** address, size_t size);为某个变量分配size字节的线性内存。
* 双重指针的意图：修改指针本身的值，而非指针所指向的内容，另外函数返回值已被返回错误代号占用，因此不能使用函数返回值返回被修改的指针，因此使用双重指针的做法。
* CUDA编程的传统，使用d_作为所有设备变量的前缀，使用h_作为对应主机变量的前缀。
* 设备内存的释放 —— cudaFree(void* address);
* 从计算能力2.0开始，CUDA允许核函数内部使用malloc与free，但不提倡。
* 主机与设备之间数据的传递 —— cudaError_t cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);最后的枚举类型表明数据传递的方向，可以为主机到主机，主机到设备，设备到主机，设备到设备，以及（由系统自动推断的）默认值。
* 核函数支持C++中的重载，但不支持可变数量的参数列表。
* 除非使用统一内存编程机制，否则传递给核函数的指针必须指向设备内存。
* 核函数不可以做为类的成员，但可以使用一个包装函数调用核函数，而将包装函数定义为类的成员。
* 计算能力3.5后，核函数可以调用核函数（动态并行），甚至递归调用。
* 要注意在核函数内使用if语句避免出现非法的设备内存操作。

# 3.3 
* 核函数通常是设备中执行，但是在主机中调用。另一类函数被称为设备函数，其调用与执行均发生在设备中。
* 被__global__修饰的称为核函数，通常由主机调用，在设备中执行，使用动态并行下，也可以在核函数中调用自己或者其它核函数。
* 被__device__修饰的称为设备函数，只能被核函数或者其它设备函数调用，在设备中执行。
* 被__host__修饰的称为主机端普通C++函数，之所以提供这样的修饰符，是因为可以使用__host__与__device__同时修饰一个函数，使得该函数及作为C++普通函数，又作为设备函数，减少冗余代码，编译器将分别针对主机与设备编译该函数。
* 可以使用修饰符__noinline__或者__forceinline__向编译器建议设备函数为非内联或者内联，但最终由编译器决定其实现。
* 设备函数不要求以void为返回类型。